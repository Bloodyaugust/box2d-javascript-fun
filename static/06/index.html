<!DOCTYPE html>
<!--
Copyright 2011 Seth Ladd

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
-->
<html>
  <head>
    <meta charset="utf-8">
    <title>Box2D Javascript Fun : 06 : Web Workers and Box2D and Page Visibility API, Version 2</title>
    <link rel="author" href="http://profiles.google.com/sethladd">
    <script src="Stats.js"></script>
    <script src="../Box2D.js"></script>
    <script src="bTest.js"></script>
    <script type="text/javascript">
      (function() {
        var po = document.createElement('script'); po.type = 'text/javascript'; po.async = true;
        po.src = 'https://apis.google.com/js/plusone.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(po, s);
      })();
    </script>
    <style>
    body {
      -webkit-transform: translateZ(0);
    }
    </style>
  </head>
  <body>
    <h1>Box2D running in a Web worker controlled by <a href="https://developer.mozilla.org/en/API/PageVisibility/Page_Visibility_API">Page Visibility API</a>, Version 2</h1>
    <canvas id="c0" width="1024" height="768" style="border: 1px solid black"></canvas>

    <script async>
    // http://paulirish.com/2011/requestanimationframe-for-smart-animating/
    window.requestAnimFrame = (function(){
          return  window.requestAnimationFrame       || 
                  window.webkitRequestAnimationFrame || 
                  window.mozRequestAnimationFrame    || 
                  window.oRequestAnimationFrame      || 
                  window.msRequestAnimationFrame     || 
                  function(/* function */ callback, /* DOMElement */ element){
                    window.setTimeout(callback, 1000 / 60);
                  };
    })();
    </script>
    
    <script async>
    
    var drawStats = new Stats(true);
    drawStats.showMode(1);
    var updateStats = new Stats(true);
    updateStats.showMode(1);
    var fpsStats = new Stats(true);
    
    document.body.appendChild(drawStats.domElement);
    document.body.appendChild(updateStats.domElement);
    document.body.appendChild(fpsStats.domElement);
    
    var SCALE = 30;
    
    function Entity(id, x, y) {
      this.id = id;
      this.x = x;
      this.y = y;
      this.angle = 0;
    }
    
    Entity.prototype.update = function(state) {
      this.x = state.x;
      this.y = state.y;
      this.angle = state.a;
    }
    
    Entity.prototype.draw = function(ctx) {
      ctx.fillStyle = 'black';
      ctx.beginPath();
      ctx.arc(this.x * SCALE, this.y * SCALE, 2, 0, Math.PI * 2, true);
      ctx.closePath();
      ctx.fill();
    }
    
    function CircleEntity(id, x, y, radius) {
      Entity.call(this, id, x, y);
      this.radius = radius;
    }
    CircleEntity.prototype = new Entity();
    CircleEntity.prototype.constructor = CircleEntity;
    
    CircleEntity.prototype.draw = function(ctx) {
      ctx.fillStyle = 'blue';
      ctx.beginPath();
      ctx.arc(this.x * SCALE, this.y * SCALE, this.radius * SCALE, 0, Math.PI * 2, true);
      ctx.closePath();
      ctx.fill();
      
      Entity.prototype.draw.call(this, ctx);
    }
    
    function RectangleEntity(id, x, y, halfWidth, halfHeight) {
      Entity.call(this, id, x, y);
      this.halfWidth = halfWidth;
      this.halfHeight = halfHeight;
    }
    RectangleEntity.prototype = new Entity();
    RectangleEntity.prototype.constructor = RectangleEntity;
    
    RectangleEntity.prototype.draw = function(ctx) {
      ctx.save();
      ctx.translate(this.x * SCALE, this.y * SCALE);
      ctx.rotate(this.angle);
      ctx.translate(-(this.x) * SCALE, -(this.y) * SCALE);
      ctx.fillStyle = 'red';
      ctx.fillRect((this.x-this.halfWidth) * SCALE,
                   (this.y-this.halfHeight) * SCALE,
                   (this.halfWidth*2) * SCALE,
                   (this.halfHeight*2) * SCALE);
      ctx.restore();
      
      Entity.prototype.draw.call(this, ctx);
    }
    
    function randomEntity(id) {
      var x = Math.random() * 35;
      var y = Math.random() * 10;
      
      if (Math.random() > 0.5) {
        return new CircleEntity(id, x, y, Math.random() + 0.1);
      } else {
        return new RectangleEntity(id, x, y, Math.random() + 0.1, Math.random() + 0.1);
      }
    }
    
    var world = {};
    for (var i = 0; i < 120; i++) {
      world[i] = randomEntity(i);
    }
    
    var USE_WORKER = window.location.href.indexOf('worker') > 0;
    var worker = null;
    
    var bodiesState = null;
    
    if (USE_WORKER) {
      worker = new Worker('physics.js');
      worker.postMessage({'cmd': 'bodies', 'msg': world});

      document.addEventListener('webkitvisibilitychange', function() {
        if (document.webkitHidden) {
          worker.postMessage({'cmd': 'hidden'});
        } else {
          worker.postMessage({'cmd': 'visible'});
        }
      }, false);

      worker.onmessage = function(e) {
        bodiesState = e.data;
      };
    } else {
      var box = new bTest(60, false);
      box.setBodies(world);
    }

    
    function update(animStart) {
      updateStats.start();
      if (!USE_WORKER) {
        box.update();
        bodiesState = box.getState();
      } else {
        // ask for box to sim out to the next frame
        worker.postMessage({'cmd':'req'});
      }
      for (var id in bodiesState) {
        var entity = world[id];
        if (entity) entity.update(bodiesState[id]);
      }
      updateStats.update();
    }
    
    var ctx = document.getElementById("c0").getContext("2d");
    var canvasWidth = ctx.canvas.width;
    var canvasHeight = ctx.canvas.height;
    
    function draw() {
      drawStats.start();
      ctx.clearRect(0, 0, canvasWidth, canvasHeight);
      for (var id in world) {
        var entity = world[id];
        entity.draw(ctx);
      }
      drawStats.update();
      fpsStats.update();
    }
    
    document.addEventListener("DOMContentLoaded", function() {
      (function loop(animStart) {
        update(animStart);
        draw();
        requestAnimFrame(loop);
      })();
    }, false);

    </script>
    
    <ol>
      <li>Draw time</li>
      <li>Update time</li>
      <li>FPS</li>
    </ol>
    
    <p><a href="index.html?worker">Use Worker</a> or <a href="index.html">Use Inline</a> Wondering which one you are using now? Check URL, if ?worker is there, you are using worker.</p>
    
    <p>
      Read matching blog post for explanation
    </p>
    
    <div class="g-plusone" data-size="small" data-annotation="inline"></div>
  </body>
</html>