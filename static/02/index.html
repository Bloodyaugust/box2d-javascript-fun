<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>Box2D Javascript Fun : 02</title>
    <style>
    div.box {
      width: 650px;
      float: left;
    }
    </style>
    <script src="../Box2d.min.js"></script>
  </head>
  <body>
    <div class="box" id="sim-1">
     <div>
       <canvas width="640" height="480" style="border: 1px solid black"></canvas>
     </div>
     <div>
      FPS: <input type="range" min="1" max="60" class="fps" value="60"> <output class="fps-output">60</output>
     </div>
     <div>
      Step Freq: <input type="range" min="1" max="60" class="step-freq" value="60"> <output class="step-freq-output">60</output>
     </div>
     <div>
      Adaptive Step Freq: <input type="checkbox" class="adaptive-step-freq">
     </div>
    </div>
    
    <div class="box" id="sim-2">
     <div>
       <canvas width="640" height="480" style="border: 1px solid black"></canvas>
     </div>
     <div>
      FPS: <input type="range" min="1" max="60" class="fps" value="30"> <output class="fps-output">30</output>
     </div>
     <div>
      Step Freq: <input type="range" min="1" max="60" class="step-freq" value="30"> <output class="step-freq-output">30</output>
     </div>
     <div>
      Adaptive Step Freq: <input type="checkbox" class="adaptive-step-freq">
     </div>
    </div>
    
    <script>
    // http://paulirish.com/2011/requestanimationframe-for-smart-animating/
    window.requestAnimFrame = (function(){
          return  window.requestAnimationFrame       || 
                  window.webkitRequestAnimationFrame || 
                  window.mozRequestAnimationFrame    || 
                  window.oRequestAnimationFrame      || 
                  window.msRequestAnimationFrame     || 
                  function(/* function */ callback, /* DOMElement */ element){
                    window.setTimeout(callback, 1000 / 60);
                  };
    })();
    </script>
    
    <!-- set listeners and handlers -->
    <script>
    var linkInputOutput = function(selector) {
      var inputs = document.querySelectorAll("input." + selector);
      for (var i = 0; i < inputs.length; i++) {
        inputs[i].addEventListener("change", function(e) {
          var output = e.target.parentNode.querySelector("output." + selector + "-output");
          if (e.target.disabled) {
            output.value = '';
          } else {
            output.value = e.target.value;
          }
        });
      }
    }
    
    linkInputOutput("fps");
    linkInputOutput("step-freq");
    
    (function () {
      var adaptives = document.querySelectorAll("input.adaptive-step-freq");
      for (var i = 0; i < adaptives.length; i++) {
        adaptives[i].addEventListener("change", function(e) {
          var stepRangeFreq = e.target.parentNode.parentNode.querySelector("input.step-freq");
          var stepRangeFreqOutput = e.target.parentNode.parentNode.querySelector("output.step-freq-output");
          if (e.target.checked) {
            stepRangeFreq.disabled = true;
            stepRangeFreqOutput.value = '';
          } else {
            stepRangeFreq.disabled = false;
            stepRangeFreqOutput.value = stepRangeFreq.value;
          }
        });
      }
    })();
    </script>
    
    <script>
  
    var bTest = function(canvasId, intervalRate, frameRate, adaptive) {
      
      if (typeof(adaptive) === 'undefined') adaptive = false;
      var lastTimestamp = Date.now();
      
      var world;
      
      function scheduleNextFrame() {
        var iRate = intervalRate;
        if (intervalRate === 0) {
          iRate = 60 - Math.ceil(Math.random()*20);
        }
        setTimeout(update, 1000 / iRate);
      }
  
      function init() {
         var   b2Vec2 = Box2D.Common.Math.b2Vec2
          , b2BodyDef = Box2D.Dynamics.b2BodyDef
          , b2Body = Box2D.Dynamics.b2Body
          , b2FixtureDef = Box2D.Dynamics.b2FixtureDef
          , b2Fixture = Box2D.Dynamics.b2Fixture
          , b2World = Box2D.Dynamics.b2World
          , b2MassData = Box2D.Collision.Shapes.b2MassData
          , b2PolygonShape = Box2D.Collision.Shapes.b2PolygonShape
          , b2CircleShape = Box2D.Collision.Shapes.b2CircleShape
          , b2DebugDraw = Box2D.Dynamics.b2DebugDraw
            ;
     
         world = new b2World(
               new b2Vec2(0, 10)    //gravity
            ,  true                 //allow sleep
         );
       
         var SCALE = 30;
     
         var fixDef = new b2FixtureDef;
         fixDef.density = 1.0;
         fixDef.friction = 0.5;
         fixDef.restitution = 0.2;
     
         var bodyDef = new b2BodyDef;
     
         //create ground
         bodyDef.type = b2Body.b2_staticBody;
       
         // positions the center of the object (not upper left!)
         bodyDef.position.x = 640 / 2 / SCALE;
         bodyDef.position.y = 480 / SCALE;
       
         fixDef.shape = new b2PolygonShape;
       
         // half width, half height. eg actual height here is 1 unit
         fixDef.shape.SetAsBox((600 / SCALE) / 2, (10/SCALE) / 2);
         world.CreateBody(bodyDef).CreateFixture(fixDef);
     
         //create some objects
         bodyDef.type = b2Body.b2_dynamicBody;
         for(var i = 0; i < 10; ++i) {
            if(Math.random() > 0.5) {
               fixDef.shape = new b2PolygonShape;
               fixDef.shape.SetAsBox(
                     Math.random() + 0.1 //half width
                  ,  Math.random() + 0.1 //half height
               );
            } else {
               fixDef.shape = new b2CircleShape(
                  Math.random() + 0.1 //radius
               );
            }
            bodyDef.position.x = Math.random() * 25;
            bodyDef.position.y = Math.random() * 10;
            world.CreateBody(bodyDef).CreateFixture(fixDef);
         }
     
         //setup debug draw
         var debugDraw = new b2DebugDraw();
         debugDraw.SetSprite(document.getElementById(canvasId).getContext("2d"));
         debugDraw.SetDrawScale(SCALE);
         debugDraw.SetFillAlpha(0.3);
         debugDraw.SetLineThickness(1.0);
         debugDraw.SetFlags(b2DebugDraw.e_shapeBit | b2DebugDraw.e_jointBit);
         world.SetDebugDraw(debugDraw);
     
         scheduleNextFrame();
      }; // init()
      
      function update() {
        var now = Date.now();
        var stepRate = (adaptive) ? (now - lastTimestamp) / 1000 : (1 / frameRate);
        lastTimestamp = now;
         world.Step(
               stepRate   //frame-rate
            ,  10       //velocity iterations
            ,  10       //position iterations
         );
         world.DrawDebugData();
         world.ClearForces();
         scheduleNextFrame();
      }; // update()
  
      init();
    };
    </script>
  </body>
</html>